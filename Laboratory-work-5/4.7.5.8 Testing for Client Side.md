## Тестування на стороні клієнта

### Резюме
Ін’єкція SQL на стороні клієнта відбувається, коли програма реалізує технологію веб-бази даних SQL і не перевіряє належним чином вхідні дані та не параметризує свої змінні запиту. Цією базою даних маніпулюють за допомогою викликів API JavaScript (JS), наприклад openDatabase(), який створює або відкриває існуючу базу даних.

### Цілі тесту
Наступний тестовий сценарій перевірить, чи проведено належну перевірку вхідних даних. Якщо реалізація вразлива, зловмисник може прочитати, змінити або видалити інформацію, що зберігається в базі даних.

### Як тестувати
#### Визначте використання бази даних Web SQL
Якщо перевірена програма реалізує базу даних Web SQL, у ядрі на стороні клієнта використовуватимуться наступні три виклики:
-   `openDatabase()`
-   `transaction()`
-   `executeSQL()`

Код нижче показує приклад реалізації API:
```
var db = openDatabase(shortName, version, displayName, maxSize);

db.transaction(function(transaction) {
    transaction.executeSql('INSERT INTO LOGS (time, id, log) VALUES (?, ?, ?)', [dateTime, id, log]);
});
```
#### Впровадження Web SQL DB
Після підтвердження використання `executeSQL()` зловмисник готовий протестувати та підтвердити безпеку його впровадження.
Реалізація Web SQL DB базується на синтаксисі SQLite.
#### Обхід умов
У наступному прикладі показано, як це можна використати на стороні клієнта:
```
// URL example: https://example.com/user#15
var userId = document.location.hash.substring(1,); // Grabs the ID without the hash -> 15

db.transaction(function(transaction){
    transaction.executeSQL('SELECT * FROM users WHERE user = ' + userId);
});
```
Щоб повернути інформацію про всіх користувачів, а не лише про користувача, який відповідає зловмиснику, можна використати наступне: `15 АБО 1=1` у фрагменті URL-адреси.
Щоб отримати додаткові корисні навантаження SQL Injection, перейдіть до сценарію Testing for SQL Injection.

### Виправлення
Дотримуйтеся того самого виправлення, описаного в розділі виправлення тестування ін’єкції SQL.
